## generated by RPythonic 0.4.5a
## http://code.google.com/p/rpythonic/
import os, sys, ctypes, inspect
__os = os
__sys = sys
__inspect = inspect

PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert from is pass'.split()


IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)

_ISPYTHON2 = sys.version_info[0] == 2
if _ISPYTHON2: _NULLBYTE = '\0'
else: _NULLBYTE = bytes( chr(0), 'ascii' )

def _CHARP2STRING( charp, encoding='utf-8' ):
	b = bytes()
	i = 0
	while True:
		char = charp[ i ]
		if char == _NULLBYTE: break
		else:
			b += char
			i += 1
	return b.decode( encoding )

## try to load precompiled c-libraries from this directory, if the library is not there try to load from the system.
_clibs_dir = os.path.dirname(os.path.abspath(__file__))

def _load_ctypes_lib( name ):
	if __os.name == 'posix':
		if __sys.platform.startswith('linux'):
			if not name.endswith('.so'): name += '.so'
			if not name.startswith('lib'): name = 'lib' + name

			if IS32BIT: 	path = __os.path.join(_clibs_dir,'linux32')
			else: 		path = __os.path.join(_clibs_dir,'linux64')
			url = __os.path.join( path, name )
			if __os.path.isfile( url ): return ctypes.CDLL(url)
			elif __os.path.isfile( '/usr/local/lib/%s'%name ): return ctypes.CDLL('/usr/local/lib/%s'%name)
			elif __os.path.isfile( '/usr/local/lib64/%s'%name ) and not IS32BIT: return ctypes.CDLL('/usr/local/lib64/%s'%name)
			elif __os.path.isfile( '/usr/lib/%s'%name ): return ctypes.CDLL('/usr/lib/%s'%name)
			elif __os.path.isfile( './%s'%name ): return ctypes.CDLL('./%s'%name)
			else:	# fallback
				try: return ctypes.CDLL(name)
				except: return ctypes.CDLL('')

		elif sys.platform == 'darwin':
			name += '.dylib'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'osx32')
			else: 		path = os.path.join(_clibs_dir,'osx64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			else: return ctypes.CDLL(name) #fallback

	elif os.name == 'nt':
		name += '.dll'
		if IS32BIT: 	path = os.path.join(_clibs_dir,'win32')
		else: 		path = os.path.join(_clibs_dir,'win64')
		url = os.path.join( path, name )
		if os.path.isfile( url ): return ctypes.CDLL(url)
		else: return ctypes.CDLL(name) #fallback

RPYTHONIC_WRAPPER_FUNCTIONS = {}
RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES = []
RPYTHONIC_AUTOPREFIX_IGNORE = []

## ctypes does not clearly expose these types ##
PyCFuncPtrType = type(ctypes.CFUNCTYPE(ctypes.c_void_p))
PyCArrayType = type( ctypes.c_int * 2 )
PyCPointerType = type( ctypes.POINTER(ctypes.c_int) )
PyCStructType = type( ctypes.Structure )
CArgObject = type( ctypes.byref(ctypes.c_int()) )

class _rpythonic_meta_(object):
	'''
	Reserved Attributes:
		POINTER
		CSTRUCT
		CAST
	'''
	_rpythonic_ = True		# workaround for now, must have a way to know if object is a meta from another module, isinstance(o,_rpythonic_meta_) will fail in those cases. another workaround could be check sys.modules for other rpythonic modules and fetch _rpythonic_meta_ from there.
	def __init__(self, *args, **kw ):							# cheap trick, abuse **kw, and look for "pointer", "cast"
		if kw and 'pointer' not in kw: raise SyntaxError	# sorry, you can not init with keywords
		elif kw and 'pointer' in kw:
			if 'cast' in kw and kw['cast']:
				self.POINTER = ctypes.cast( kw['pointer'], ctypes.POINTER(self.CSTRUCT) )
			else: self.POINTER = kw['pointer']
		else: self.POINTER = ctypes.pointer( self.CSTRUCT(*args) )
		self.POINTER.pyobject = self	# .pyobject is local to this pointer "object"

	def __getattr__(self,name):
		if hasattr( self.POINTER.contents, name ):
			return getattr( self.POINTER.contents, name )

		else:	# when rpythonic failed to generate good bindings - these lookups should be cached
			for parent in self._rpythonic_parent_classes_:
				if hasattr( parent, name ):
					method = getattr( parent, name )	# should check if it really is an unbound method
					if method in parent._rpythonic_unbound_lookup_:
						func = parent._rpythonic_unbound_lookup_[ method ]
						n = func.name
						if len(func.argnames) > 1:
							argnames = func.argnames[ 1 : ]
							a = ',' + '=None,'.join( argnames ) + '=None'
							b = ','.join( argnames )
						else: a = b = ''
						lamb = eval( 'lambda self %s: %s( self.POINTER, %s )' %(a,n,b) )
						setattr( self.__class__, name, lamb )
						#return lamb	# this would return the unbound lambda, must call getattr again
						return getattr( self, name )
					else:
						# this can happen if self also inherits from the same parent class,
						# assume that by continuing this reaches that shared parent class,
						# and the lambda above is created as normal.
						continue
			## last resort, load from global name space ##
			G = globals()
			if name in G: return lambda *args: G[name](self.POINTER, *args)
			else:
				for prefix in self._autoprefix_:
					n = prefix + name
					if n in G: return lambda *args: G[n](self.POINTER, *args)
				print( 'possible auto-prefixes available', self._autoprefix_ )
				raise AttributeError

	def __call__(self, type=False):
		print('calling object is DEPRECATED - use ob.POINTER or ob.CSTRUCT')
		if type: return self.CSTRUCT
		else: return self.POINTER


def _rpythonic_generate_subclass_( name, struct, functions ):
	head = 'class %s( _rpythonic_meta_ ):' %name
	body = [ 
		'_rpythonic_parent_classes_ = []' ,
		'_rpythonic_unbound_lookup_ = {}' 
	]

	names = [ func.name for func in functions ]

	possibles = {}
	rank = []		# rank by longest name
	if len(names) > 3000: print('too many functions to use this hack')
	else:
		for n1 in names:
			prefix = ''
			for i,char in enumerate(n1):
				prefix += char
				if prefix not in possibles:
					possibles[ prefix ] = 0
					for n2 in names:
						if n2.startswith( prefix ):
							possibles[ prefix ] += 1

					if not rank or len(prefix) > len(rank[-1]) and possibles[prefix] > len(names)/4:
						rank.append( prefix )

	top = []
	while rank:
		best = rank.pop()
		if possibles[best] > len(functions)/2 and best not in names:
			if best.endswith('_set_') or best.endswith('_get_'): best = best[ : -4 ]
			elif best.endswith('Set') or best.endswith('Get'): best = best[ : -3 ]

			rem = []
			for other in rank:
				if best.startswith(other): rem.append( other )
			for r in rem: rank.remove( r )

			if best not in top: top.append( best )

		if len(top) > 3: break

	for n in names:		# find shortest prefixes #
		prefix = ''
		for i,char in enumerate(n):		# cammelCase
			if i==0: prefix += char; continue
			if char.isupper() and len(prefix) >= 2: break
			prefix += char
		if prefix and prefix != n and len(prefix) >= 2:
			hits = 0
			for other in names:
				if other.startswith( prefix ): hits += 1
			if hits >= 2 and prefix not in top:
				top.append( prefix )
				if len(top) >= 6: break

	## setup full names
	for func in functions:
		n = func.name
		if len(func.argnames) > 1:
			argnames = func.argnames[ 1 : ]
			a = ',' + '=None,'.join( argnames ) + '=None'
			b = ','.join( argnames )
		else: a = b = ''

		fhead = 'def %s( self %s ):' %(n,a)
		fbody = ['return %s(self.POINTER, %s)' %(func.name,b)]
		g = fhead + '\n\t\t' + '\n\t\t'.join( fbody )
		body.append( g )
		#body.append( '%s._rpythonic_function_ = %s' %(func.name, func.name) )

	## setup short names ##
	for n in names:
		for prefix in top:
			if n.startswith(prefix) and n[len(prefix):] not in names:
				alt = n[ len(prefix) : ]
				if alt and alt != n and alt not in PYTHON_RESERVED_KEYWORDS and not alt.isdigit() and not alt[0].isdigit():
					body.append( '%s = %s' %(alt,n) )
					names.append( alt )

	gen = head + '\n\t' + '\n\t'.join( body )
	try: exec( gen )
	except:
		print( gen )
		raise SyntaxError

	klass = locals()[name]
	klass.CSTRUCT = struct	# ctypes struct class

	klass._autoprefix_ = top
	for func in functions:
		unbound = getattr( klass, func.name )
		klass._rpythonic_unbound_lookup_[ unbound ] = func
		# klass.longname is klass.shortname = False
		# klass.longname == klass.shortname = True
	return klass

def _rpythonic_convert_structs_to_objects():
	G = globals()
	for klass in _OOAPI_:
		altname = name = klass.__name__
		prefix = ''
		for i,char in enumerate(name):
			if i==0: prefix += char; continue
			if char.isupper(): break
			prefix += char
		if prefix and prefix != name:
			hits = 0
			for other in _OOAPI_:
				if other is not klass:
					if other.__name__.startswith( prefix ): hits += 1
			if hits >= 2:
				altname = name[ len(prefix) : ]

		funcs = _OOAPI_[ klass ]
		newklass = _rpythonic_generate_subclass_( altname, klass, funcs )
		klass._rpythonic_wrapper_class_ = newklass
		G[ name ] = newklass	# replace struct with wrapper
		if altname not in G: G[ altname ] = newklass	# safely define with nicer name
		elif altname != name: # odd cases, maybe a function that returns the object, almost never happens.
			print('WARN - not replacing something with struct wrapper:', G[altname] )


def _rpythonic_setup_return_wrappers():
	R = _rpythonic_function_
	for klass in _OOAPI_:
		if klass in _OOAPI_RETURNS_OBJECT_:
			for f in _OOAPI_RETURNS_OBJECT_[klass]:
				f.object_oriented = True
				if not f.return_wrapper:	# just in case the ctypes footer had already defined it, do not overwrite
					f.return_wrapper = klass._rpythonic_wrapper_class_

def _rpythonic_function_( name, result=ctypes.c_void_p, args=[]):
	mname = '_metafunc_%s' %name
	exec( 'class %s( _rpythonic_metafunc_ ): pass' %mname )
	k = locals()[mname]
	return k( name, result, args )

_OOAPI_ = {}
_OOAPI_RETURNS_OBJECT_ = {}

class _rpythonic_metafunc_(object):
	def __init__(self, name, result=ctypes.c_void_p, args=[]):
		self.name = name
		self.result = result
		self.argtypes = []		# can dynamically change CFUNCTYPE trick
		self.argnames = []
		self.argtypestypes = []
		for i,arg in enumerate(args):
			n,t = arg
			if n in PYTHON_RESERVED_KEYWORDS: n = 'C_'+n
			if n in self.argnames: n = '%s%s' %(n,i)
			self.argnames.append( n )
			self.argtypes.append( t )
			self.argtypestypes.append( type(t) )		# precomputed for speed

		self.argnames = tuple( self.argnames )				# should never change
		self.numargs = len( self.argtypes )
		self.callbacks = [None] * self.numargs
		self.return_wrapper = None
		self.object_oriented = False
		self.function = None
		try:
			func = self.function = getattr(CTYPES_DLL, self.name )
			RPYTHONIC_WRAPPER_FUNCTIONS[ name ] = self
		except:
			RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES.append( name )
		if self.function: self.reset()

	def change_argument_type( self, name, t ):
		idx = self.argnames.index( name )
		self.argtypes[ idx ] = t
		self.argtypestypes[ idx ] = type(t)
		self.function.argtypes = self.argtypes

	def reset(self):
		if self.argnames:
			a = ',' + '=None,'.join( self.argnames ) + '=None'
			b = ','.join( self.argnames )
		else: a = b = ''

		callmeth = eval( 'lambda self %s: self._call_( %s )' %(a,b) )
		setattr( self.__class__, '__call__', callmeth )

		self.function.restype = self.result
		self.function.argtypes = self.argtypes

		if type( self.result ) is PyCPointerType and type(self.result._type_) is PyCStructType:
			klass = self.result._type_
			if klass not in _OOAPI_RETURNS_OBJECT_: _OOAPI_RETURNS_OBJECT_[klass] = []
			_OOAPI_RETURNS_OBJECT_[klass].append( self )

		self.defaults = []
		for i in range( self.numargs ):
			T = self.argtypes[ i ]
			if type(T) is PyCFuncPtrType:
				p = T()	# func pointers can not be None
				self.defaults.append( p )
				self.callbacks[ i ] = p					# save reference
			elif T in (ctypes.c_int, ctypes.c_uint, ctypes.c_long, ctypes.c_ulong):
				self.defaults.append( 0 )
			elif T in (ctypes.c_float, ctypes.c_double):
				self.defaults.append( .0 )
			else: self.defaults.append( None )	# None is allowed for all other types

			## generate OO API ##
			if i == 0 and type(T) is PyCPointerType and type(T._type_) is PyCStructType:
				klass = T._type_
				if klass not in _OOAPI_: _OOAPI_[ klass ] = []
				_OOAPI_[ klass ].append( self )

	def _call_( self, *args ):			# allow flexible calling types
		cargs = list( self.defaults )
		for i,arg in enumerate(args):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER
			elif hasattr( arg, '_rpythonic_' ): arg = arg.POINTER		# workaround - instance from another module

			t = type(arg)
			k = self.argtypes[ i ]
			kt = self.argtypestypes[ i ]
			if arg is None and cargs[i] is not None:	# use user defaults, very rare cases
				continue

			elif t is bool and k is ctypes.c_int:
				if arg: cargs[i] = 1	#ctypes.c_int(1)
				else: cargs[i] = 0	#ctypes.c_int(0)

			elif t in (list,tuple):				# convert lists and tuples into array
				if kt is PyCArrayType:
					cargs[ i ] = k(*arg)
				elif kt is PyCStructType:
					if k._array_wrapper_: cargs[ i ] = k(arg)	# allow easy array init
					else: cargs[ i ] = k(*arg)							# allow multiple args
				elif kt is PyCPointerType:
					cargs[ i ] = _convert_nested_list_to_pointer( k, arg )
				else: assert 0

			elif isinstance( arg, ctypes._Pointer ) and t is not k and kt is PyCPointerType:
				cargs[ i ] = ctypes.cast( arg, k )		# generic's that need to be cast

			elif kt is PyCStructType and isinstance( arg, ctypes._Pointer ):
				cargs[ i ] = arg.contents	# fixed may25

			elif kt is PyCPointerType and not isinstance( arg, (ctypes._Pointer,CArgObject) ):
				if t in (int,float,bool): ptr = k( k._type_(arg) )
				elif t is str:
					arg = arg.encode('utf-8')
					#ptr = k( k._type_() )								# not k() otherwise null pointer error
					#for j, char in enumerate(arg): ptr[ j ] = char		# not correct - missing null byte?
					ptr = ctypes.create_string_buffer(arg)				# correct and pypy compatible
				elif t in (PyCStructType, PyCArrayType):
					ptr = ctypes.cast( ctypes.pointer( arg ), k )
				else:
					ptr = arg	# TODO print warning?
				cargs[ i ] = ptr

			elif kt is PyCFuncPtrType:
				if t.__name__ == 'CFunctionType': cargs[ i ] = arg		# assume outside holds pointer
				else:													# this is not safe #
					cargs[ i ] = self.callbacks[ i ] = k( arg )				# assume arg is a callable
			else:
				cargs[ i ] = arg		# directly pass

		## if you define your own return_wrapper, it must take keyword "pointer"
		if self.return_wrapper: return self.return_wrapper( pointer=self.function( *cargs ) )
		else: return self.function( *cargs )



def _convert_nested_list_to_pointer( k, arg ):
	depth = 0; s = k
	while True:
		if type(s) is PyCPointerType:
			s = getattr( s, '_type_' )
			depth += 1
		else: break
	assert depth and depth <= 2
	if depth == 1:
		T = k._type_
		ptr = k( k._type_() )
		for i in range( len(arg) ):
			ptr[ i ] = T( *arg[i] )
	elif depth == 2:
		T = k._type_._type_
		_ptr = k._type_( k._type_._type_() )
		for i in range(len( arg )):
			for j in range( len(arg[i]) ):
				_ptr[ j ] = T( *arg[ i ][ j ] )
		ptr = k( _ptr )
	return ptr


def __freeze_rpythonic_struct( cls, fields ):
	if cls not in _OOAPI_: _OOAPI_[ cls ] = []	# wrap all structs
	try: setattr( cls, '_fields_', fields )
	except:
		print( 'WARN - bad order struct freeze', cls )
		#cls._fields_ = []

class _rpythonic_struct_( ctypes.Structure ):
	_array_wrapper_ = False
	_fields_ = []
	_methods_ = {}
	#def __call__(self): return self
	def __init__(self, *args, **kw ):
		cargs = []
		argtypes = []
		for a in self._fields_: argtypes.append( a[1] )
		if len(args) > len(argtypes): args = [args]	# allow both calling conventions
		for i,arg in enumerate( args ):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER

			t = type(arg)
			k = argtypes[ i ]
			if t in (list,tuple):
				if k.__class__.__name__	== 'PyCArrayType':
					cargs.append( k(*arg) )
				elif k.__class__.__name__ == 'PyCStructType':
					if k._array_wrapper_: cargs.append( k(arg) )	# allow easy array init
					else: cargs.append( k(*arg) )							# allow multiple args
			elif isinstance( arg, ctypes._Pointer ) and t is not k:
				cargs[ i ] = ctypes.cast( arg, k )	# generic's that need to be cast
			elif k.__class__.__name__ == 'PyCArrayType' and t in (float,int,bool):
				cargs.append( k(arg) )		# support init array from single value
			else:
				cargs.append( arg )		# directly pass

		ctypes.Structure.__init__(self, *cargs, **kw)


def _rpythonic_make_nice_global_enums_():
	G = globals()
	for name in RPYTHONIC_GLOBAL_ENUMS:
		if '_' in name and name.index('_') <= 4:
			altname = name[ name.index('_') + 1 : ]
			if altname not in G:
				G[altname] = RPYTHONIC_GLOBAL_ENUMS[ name ]

def _rpythonic_clean_up_missing_functions_():
	G = globals()
	for f in RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES:
		G.pop( f )
	print( "C functions loaded: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS) )
	print( "C functions failed: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES) )



###### NEW API #########
CTYPES_DLL = None

class _VOID_POINTER_CONTAINER_(object):
	def __init__(self, ptr, name=None):
		self._pointer_ = ptr
		self.name = name
NULL = _VOID_POINTER_CONTAINER_(None,'<null pointer>')


class meta:	# NEW API - allow run time switch from ctypes to rffi
	'''
	Methods:
		RPython will not allow object wrapper around a method (__call__ not allowed)
		keep C function names in list "__cfunctions__"
		rpythonic.enable_rffi( classA, classB )	
		can take advantage of methods in object-method-wrapper,
		generate rffi wrapper and set method on classA, etc.
		replaces object-method-wrapper with rffi-method

	Properties:
		CPython: obj.x=1
		RPython: obj.set_x(1)	
	'''
	METAS = []
	def __init__(self, constructors=[], methods={}, properties={}):
		global CTYPES_DLL
		if not CTYPES_DLL:
			CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		self.constructors = constructors
		self.methods = methods
		self.properties = properties
		self.METAS.append( self )



	def __call__(self, cls ):
		print('@meta', cls )

		if not self.constructors:
			lamb = lambda s, _explicit_pointer_=None: setattr(s,'_pointer_',getattr(_explicit_pointer_,'_pointer_')) if hasattr(_explicit_pointer_,'_pointer_') else setattr(s,'_pointer_',_explicit_pointer_)
			lamb._debug = '(no constructor)'
			setattr( cls, '__init__', lamb )
		else:
			con = self._find_best_function( self.constructors )
			cfunc = self._build_cfunc( con )
			setattr( cls, '_%s'%con['name'], cfunc )
			g = self._gen_init( con )
			setattr( cls, '__init__', g )
		
		## set methods ##
		for name in self.methods:
			meth = self.methods[ name ]
			cfuncs = []
			for m in meth['functions']:
				cfunc = self._build_cfunc( m, method=True, static=meth['static'] )
				self._setup_return( cfunc, meth )
				setattr( cls, '_%s'%m['name'], cfunc )
				cfuncs.append( cfunc )

			f = self._find_best_function( meth['functions'] )
			g = self._gen_method( meth, f )
			g._cfuncs = cfuncs
			if meth['static']: g = classmethod( g )
			setattr( cls, name, g )

		for name in self.properties:
			print( 'property:', name )
			p = []
			for f in self.properties[name]:
				cfunc = self._build_cfunc( f )
				setattr( cls, '_%s'%f['name'], cfunc )
				g = self._gen_method( f, f )
				p.append( g )

			setattr( cls, name, property(*p) )

		return cls


	@staticmethod
	def _build_cfunc( info, method=False, static=False ):
		cfunc = getattr(CTYPES_DLL, info['name'])
		if method and not static: argtypes = [ ctypes.c_void_p ]
		else: argtypes = []
		for p in info['parameters']: argtypes.append( eval(p['ctypes_type']) )
		cfunc.argtypes = argtypes
		return cfunc

	@staticmethod
	def _setup_return( cfunc, info ):
		if not info['returns_fundamental']:
			cfunc.restype = ctypes.c_void_p
		elif info['returns_fundamental']:
			cfunc.restype = eval( info['returns_ctypes'] )
		else:
			cfunc.restype = ctypes.c_void_p

	@staticmethod
	def _gen_prepare_args( m ):
		a = []; b = []
		for i,p in enumerate(m['parameters']):
			if 'name' in p: n = p['name']
			else: n = '_unnamed_%s' %i
			if '<' in n: n = '_TODOfixme_%s' %i
			if n in PYTHON_RESERVED_KEYWORDS: n += str(i)
			if p['fundamental']:
				b.append( n )
				s = p['raw_type'].split()
				if 'default' in p:
					d = p['default']
					if p['raw_type'] in ('float', 'double'):
						if d.endswith('f'): d = d[:-1]
						d = d.replace(' ', '.')
						if 'e' in d: d = 0.0
						try: d = float(d)
						except: d = 0.0
					elif ('int' in s or 'size_t' in s) and not d.isdigit(): d = 0
					elif 'char' in s and '"' not in d: d = '""'
					elif d.lower() == 'false': d = False
					elif d.lower() == 'true': d = True
				elif 'char' in s: d = '""'
				elif 'float' in s or 'double' in s: d = 0.0
				elif 'size_t' in s or 'int' in s or 'long' in s or 'short' in s: d = 0
				elif p['raw_type'] == 'bool': d = False
				elif p['raw_type'] in ('void', '(template)'): d = 'NULL'
				else: print( p )
				a.append( n+'=%s' %d )

			else:
				b.append( '%s._pointer_'%n )
				a.append( n+'=NULL' )
		return a, b

	@staticmethod
	def _gen_init( m ):
		a, b = meta._gen_prepare_args( m )
		if a: e = 'lambda _py_self_, %s, _explicit_pointer_=None: ' %(','.join(a))
		else: e = 'lambda _py_self_, _explicit_pointer_=None: '
		e += 'setattr(_py_self_, "_pointer_", _py_self_._%s(%s))' %( m['name'], ','.join(b) )
		e += ' if not _explicit_pointer_ else '
		e += 'setattr(_py_self_, "_pointer_", _explicit_pointer_)'
		print( e )
		lamb = eval( e ); lamb._debug = e; lamb._introspect = m
		return lamb

	@staticmethod
	def _find_best_function( funcs ):
		best = funcs[0]
		score = -1
		if len(funcs) > 1:
			for f in funcs:
				hits = 0
				for p in f['parameters']:
					if p['fundamental']: hits += 1
				if hits and hits == len( f['parameters'] ):
					if hits > score:
						score = hits
						best = f
		return best

	@staticmethod
	def _gen_method( m, f ):
		a, b = meta._gen_prepare_args( f )
		if a: e = 'lambda _py_self_, %s: ' %(','.join(a))
		else: e = 'lambda _py_self_: '

		if 'static' in m and m['static']:	# static in c++ is like a classmethod
			c = '_py_self_._%s( %s )' %( f['name'], ','.join(b) )
		else:
			c = '_py_self_._%s( _py_self_._pointer_, %s )' %( f['name'], ','.join(b) )

		if not m['returns_fundamental']:
			if 'returns_unknown' in m or '<' in m['returns']: c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,m['returns'])
			else:
				something = m['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)

		e += c; lamb = eval( e )
		lamb._debug = e; lamb._introspect = f
		return lamb


	META_FUNCTIONS = []
	@classmethod
	def function( self, info ):
		print('@meta.function', info['name'] )
		global CTYPES_DLL
		if not CTYPES_DLL:
			CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		cfunc = self._build_cfunc( info, method=False, static=True )
		setattr( meta, '_%s'%info['name'], cfunc )
		self._setup_return( cfunc, info )
		a, b = meta._gen_prepare_args( info )
		e = 'lambda %s: ' %(','.join(a))
		c = 'meta._%s( %s )' %( info['name'], ','.join(b) )

		if not info['returns_fundamental']:
			if 'returns_unknown' in info or '<' in info['returns']:
				c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,info['returns'])
			else:
				something = info['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)
		e += c
		lamb = eval( e )
		lamb._debug = e
		lamb._introspect = info
		return lamb



def _rpythonic_strip_prefixes_( prefixes ):
	G = globals()
	names = list(G.keys())	# ensure list in py3
	for name in names:
		for prefix in prefixes:
			if name.startswith( prefix ):
				newname = name[ len(prefix) : ]
				if newname and newname not in G:
					G[ newname ] = G[ name ]






_clib_name_ = 'libopenal'
print('loading lib', _clib_name_)
print( os.path.abspath( os.path.curdir ) )
CTYPES_DLL = _load_ctypes_lib( _clib_name_ )
assert CTYPES_DLL
print( CTYPES_DLL._name )

## macro globals ##
AL_INVALID = -1
AL_NONE = 0
AL_FALSE = 0
AL_TRUE = 1
AL_SOURCE_RELATIVE = 514
AL_CONE_INNER_ANGLE = 4097
AL_CONE_OUTER_ANGLE = 4098
AL_PITCH = 4099
AL_POSITION = 4100
AL_DIRECTION = 4101
AL_VELOCITY = 4102
AL_LOOPING = 4103
AL_BUFFER = 4105
AL_GAIN = 4106
AL_MIN_GAIN = 4109
AL_MAX_GAIN = 4110
AL_ORIENTATION = 4111
AL_SOURCE_STATE = 4112
AL_INITIAL = 4113
AL_PLAYING = 4114
AL_PAUSED = 4115
AL_STOPPED = 4116
AL_BUFFERS_QUEUED = 4117
AL_BUFFERS_PROCESSED = 4118
AL_SEC_OFFSET = 4132
AL_SAMPLE_OFFSET = 4133
AL_BYTE_OFFSET = 4134
AL_SOURCE_TYPE = 4135
AL_STATIC = 4136
AL_STREAMING = 4137
AL_UNDETERMINED = 4144
AL_FORMAT_MONO8 = 4352
AL_FORMAT_MONO16 = 4353
AL_FORMAT_STEREO8 = 4354
AL_FORMAT_STEREO16 = 4355
AL_REFERENCE_DISTANCE = 4128
AL_ROLLOFF_FACTOR = 4129
AL_CONE_OUTER_GAIN = 4130
AL_MAX_DISTANCE = 4131
AL_FREQUENCY = 8193
AL_BITS = 8194
AL_CHANNELS = 8195
AL_SIZE = 8196
AL_UNUSED = 8208
AL_PENDING = 8209
AL_PROCESSED = 8210
AL_NO_ERROR = 0
AL_INVALID_NAME = 40961
AL_INVALID_ENUM = 40962
AL_INVALID_VALUE = 40963
AL_INVALID_OPERATION = 40964
AL_OUT_OF_MEMORY = 40965
AL_VENDOR = 45057
AL_VERSION = 45058
AL_RENDERER = 45059
AL_EXTENSIONS = 45060
AL_DOPPLER_FACTOR = 49152
AL_DOPPLER_VELOCITY = 49153
AL_SPEED_OF_SOUND = 49155
AL_DISTANCE_MODEL = 53248
AL_INVERSE_DISTANCE = 53249
AL_INVERSE_DISTANCE_CLAMPED = 53250
AL_LINEAR_DISTANCE = 53251
AL_LINEAR_DISTANCE_CLAMPED = 53252
AL_EXPONENT_DISTANCE = 53253
AL_EXPONENT_DISTANCE_CLAMPED = 53254
ALC_INVALID = 0
ALC_VERSION_0_1 = 1
ALC_FALSE = 0
ALC_TRUE = 1
ALC_FREQUENCY = 4103
ALC_REFRESH = 4104
ALC_SYNC = 4105
ALC_MONO_SOURCES = 4112
ALC_STEREO_SOURCES = 4113
ALC_NO_ERROR = 0
ALC_INVALID_DEVICE = 40961
ALC_INVALID_CONTEXT = 40962
ALC_INVALID_ENUM = 40963
ALC_INVALID_VALUE = 40964
ALC_OUT_OF_MEMORY = 40965
ALC_DEFAULT_DEVICE_SPECIFIER = 4100
ALC_DEVICE_SPECIFIER = 4101
ALC_EXTENSIONS = 4102
ALC_MAJOR_VERSION = 4096
ALC_MINOR_VERSION = 4097
ALC_ATTRIBUTES_SIZE = 4098
ALC_ALL_ATTRIBUTES = 4099
ALC_CAPTURE_DEVICE_SPECIFIER = 784
ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER = 785
ALC_CAPTURE_SAMPLES = 786
## enums ##

## simple enums ##
RPYTHONIC_GLOBAL_ENUMS = { 

}
class ALCdevice_struct(_rpythonic_struct_): pass
class ALCcontext_struct(_rpythonic_struct_): pass
## union and structures ##
__freeze_rpythonic_struct( ALCdevice_struct, [
])

__freeze_rpythonic_struct( ALCcontext_struct, [
])

## wrapper functions ##
alEnable = _rpythonic_function_(		"alEnable", ctypes.c_void_p, [
	("capability",		ctypes.c_int),] )

alDisable = _rpythonic_function_(		"alDisable", ctypes.c_void_p, [
	("capability",		ctypes.c_int),] )

alIsEnabled = _rpythonic_function_(		"alIsEnabled", ctypes.c_char, [
	("capability",		ctypes.c_int),] )

alGetString = _rpythonic_function_(		"alGetString", ctypes.POINTER(ctypes.c_char), [
	("param",		ctypes.c_int),] )

alGetBooleanv = _rpythonic_function_(		"alGetBooleanv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_char)),] )

alGetIntegerv = _rpythonic_function_(		"alGetIntegerv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_int)),] )

alGetFloatv = _rpythonic_function_(		"alGetFloatv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_float)),] )

alGetDoublev = _rpythonic_function_(		"alGetDoublev", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_double)),] )

alGetBoolean = _rpythonic_function_(		"alGetBoolean", ctypes.c_char, [
	("param",		ctypes.c_int),] )

alGetInteger = _rpythonic_function_(		"alGetInteger", ctypes.c_int, [
	("param",		ctypes.c_int),] )

alGetFloat = _rpythonic_function_(		"alGetFloat", ctypes.c_float, [
	("param",		ctypes.c_int),] )

alGetDouble = _rpythonic_function_(		"alGetDouble", ctypes.c_double, [
	("param",		ctypes.c_int),] )

alGetError = _rpythonic_function_(		"alGetError", ctypes.c_int, [] )

alIsExtensionPresent = _rpythonic_function_(		"alIsExtensionPresent", ctypes.c_char, [
	("extname",		ctypes.POINTER(ctypes.c_char)),] )

alGetProcAddress = _rpythonic_function_(		"alGetProcAddress", ctypes.POINTER(ctypes.c_void_p), [
	("fname",		ctypes.POINTER(ctypes.c_char)),] )

alGetEnumValue = _rpythonic_function_(		"alGetEnumValue", ctypes.c_int, [
	("ename",		ctypes.POINTER(ctypes.c_char)),] )

alListenerf = _rpythonic_function_(		"alListenerf", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.c_float),] )

alListener3f = _rpythonic_function_(		"alListener3f", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.c_float),
	("value2",		ctypes.c_float),
	("value3",		ctypes.c_float),] )

alListenerfv = _rpythonic_function_(		"alListenerfv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

alListeneri = _rpythonic_function_(		"alListeneri", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.c_int),] )

alListener3i = _rpythonic_function_(		"alListener3i", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.c_int),
	("value2",		ctypes.c_int),
	("value3",		ctypes.c_int),] )

alListeneriv = _rpythonic_function_(		"alListeneriv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

alGetListenerf = _rpythonic_function_(		"alGetListenerf", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_float)),] )

alGetListener3f = _rpythonic_function_(		"alGetListener3f", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_float)),
	("value2",		ctypes.POINTER(ctypes.c_float)),
	("value3",		ctypes.POINTER(ctypes.c_float)),] )

alGetListenerfv = _rpythonic_function_(		"alGetListenerfv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

alGetListeneri = _rpythonic_function_(		"alGetListeneri", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_int)),] )

alGetListener3i = _rpythonic_function_(		"alGetListener3i", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_int)),
	("value2",		ctypes.POINTER(ctypes.c_int)),
	("value3",		ctypes.POINTER(ctypes.c_int)),] )

alGetListeneriv = _rpythonic_function_(		"alGetListeneriv", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

alGenSources = _rpythonic_function_(		"alGenSources", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("sources",		ctypes.POINTER(ctypes.c_uint)),] )

alDeleteSources = _rpythonic_function_(		"alDeleteSources", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("sources",		ctypes.POINTER(ctypes.c_uint)),] )

alIsSource = _rpythonic_function_(		"alIsSource", ctypes.c_char, [
	("sid",		ctypes.c_uint),] )

alSourcef = _rpythonic_function_(		"alSourcef", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_float),] )

alSource3f = _rpythonic_function_(		"alSource3f", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_float),
	("value2",		ctypes.c_float),
	("value3",		ctypes.c_float),] )

alSourcefv = _rpythonic_function_(		"alSourcefv", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

alSourcei = _rpythonic_function_(		"alSourcei", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_int),] )

alSource3i = _rpythonic_function_(		"alSource3i", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_int),
	("value2",		ctypes.c_int),
	("value3",		ctypes.c_int),] )

alSourceiv = _rpythonic_function_(		"alSourceiv", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

alGetSourcef = _rpythonic_function_(		"alGetSourcef", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_float)),] )

alGetSource3f = _rpythonic_function_(		"alGetSource3f", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_float)),
	("value2",		ctypes.POINTER(ctypes.c_float)),
	("value3",		ctypes.POINTER(ctypes.c_float)),] )

alGetSourcefv = _rpythonic_function_(		"alGetSourcefv", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

alGetSourcei = _rpythonic_function_(		"alGetSourcei", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_int)),] )

alGetSource3i = _rpythonic_function_(		"alGetSource3i", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_int)),
	("value2",		ctypes.POINTER(ctypes.c_int)),
	("value3",		ctypes.POINTER(ctypes.c_int)),] )

alGetSourceiv = _rpythonic_function_(		"alGetSourceiv", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

alSourcePlayv = _rpythonic_function_(		"alSourcePlayv", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

alSourceStopv = _rpythonic_function_(		"alSourceStopv", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

alSourceRewindv = _rpythonic_function_(		"alSourceRewindv", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

alSourcePausev = _rpythonic_function_(		"alSourcePausev", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

alSourcePlay = _rpythonic_function_(		"alSourcePlay", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

alSourceStop = _rpythonic_function_(		"alSourceStop", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

alSourceRewind = _rpythonic_function_(		"alSourceRewind", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

alSourcePause = _rpythonic_function_(		"alSourcePause", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

alSourceQueueBuffers = _rpythonic_function_(		"alSourceQueueBuffers", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("numEntries",		ctypes.c_int),
	("bids",		ctypes.POINTER(ctypes.c_uint)),] )

alSourceUnqueueBuffers = _rpythonic_function_(		"alSourceUnqueueBuffers", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("numEntries",		ctypes.c_int),
	("bids",		ctypes.POINTER(ctypes.c_uint)),] )

alGenBuffers = _rpythonic_function_(		"alGenBuffers", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("buffers",		ctypes.POINTER(ctypes.c_uint)),] )

alDeleteBuffers = _rpythonic_function_(		"alDeleteBuffers", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("buffers",		ctypes.POINTER(ctypes.c_uint)),] )

alIsBuffer = _rpythonic_function_(		"alIsBuffer", ctypes.c_char, [
	("bid",		ctypes.c_uint),] )

alBufferData = _rpythonic_function_(		"alBufferData", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("format",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("size",		ctypes.c_int),
	("freq",		ctypes.c_int),] )

alBufferf = _rpythonic_function_(		"alBufferf", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_float),] )

alBuffer3f = _rpythonic_function_(		"alBuffer3f", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_float),
	("value2",		ctypes.c_float),
	("value3",		ctypes.c_float),] )

alBufferfv = _rpythonic_function_(		"alBufferfv", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

alBufferi = _rpythonic_function_(		"alBufferi", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_int),] )

alBuffer3i = _rpythonic_function_(		"alBuffer3i", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_int),
	("value2",		ctypes.c_int),
	("value3",		ctypes.c_int),] )

alBufferiv = _rpythonic_function_(		"alBufferiv", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

alGetBufferf = _rpythonic_function_(		"alGetBufferf", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_float)),] )

alGetBuffer3f = _rpythonic_function_(		"alGetBuffer3f", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_float)),
	("value2",		ctypes.POINTER(ctypes.c_float)),
	("value3",		ctypes.POINTER(ctypes.c_float)),] )

alGetBufferfv = _rpythonic_function_(		"alGetBufferfv", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

alGetBufferi = _rpythonic_function_(		"alGetBufferi", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_int)),] )

alGetBuffer3i = _rpythonic_function_(		"alGetBuffer3i", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_int)),
	("value2",		ctypes.POINTER(ctypes.c_int)),
	("value3",		ctypes.POINTER(ctypes.c_int)),] )

alGetBufferiv = _rpythonic_function_(		"alGetBufferiv", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

alDopplerFactor = _rpythonic_function_(		"alDopplerFactor", ctypes.c_void_p, [
	("value",		ctypes.c_float),] )

alDopplerVelocity = _rpythonic_function_(		"alDopplerVelocity", ctypes.c_void_p, [
	("value",		ctypes.c_float),] )

alSpeedOfSound = _rpythonic_function_(		"alSpeedOfSound", ctypes.c_void_p, [
	("value",		ctypes.c_float),] )

alDistanceModel = _rpythonic_function_(		"alDistanceModel", ctypes.c_void_p, [
	("distanceModel",		ctypes.c_int),] )

LPALENABLE = _rpythonic_function_(		"LPALENABLE", ctypes.c_void_p, [
	("capability",		ctypes.c_int),] )

LPALDISABLE = _rpythonic_function_(		"LPALDISABLE", ctypes.c_void_p, [
	("capability",		ctypes.c_int),] )

LPALISENABLED = _rpythonic_function_(		"LPALISENABLED", ctypes.c_char, [
	("capability",		ctypes.c_int),] )

LPALGETSTRING = _rpythonic_function_(		"LPALGETSTRING", ctypes.POINTER(ctypes.c_char), [
	("param",		ctypes.c_int),] )

LPALGETBOOLEANV = _rpythonic_function_(		"LPALGETBOOLEANV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_char)),] )

LPALGETINTEGERV = _rpythonic_function_(		"LPALGETINTEGERV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETFLOATV = _rpythonic_function_(		"LPALGETFLOATV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETDOUBLEV = _rpythonic_function_(		"LPALGETDOUBLEV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_double)),] )

LPALGETBOOLEAN = _rpythonic_function_(		"LPALGETBOOLEAN", ctypes.c_char, [
	("param",		ctypes.c_int),] )

LPALGETINTEGER = _rpythonic_function_(		"LPALGETINTEGER", ctypes.c_int, [
	("param",		ctypes.c_int),] )

LPALGETFLOAT = _rpythonic_function_(		"LPALGETFLOAT", ctypes.c_float, [
	("param",		ctypes.c_int),] )

LPALGETDOUBLE = _rpythonic_function_(		"LPALGETDOUBLE", ctypes.c_double, [
	("param",		ctypes.c_int),] )

LPALGETERROR = _rpythonic_function_(		"LPALGETERROR", ctypes.c_int, [] )

LPALISEXTENSIONPRESENT = _rpythonic_function_(		"LPALISEXTENSIONPRESENT", ctypes.c_char, [
	("extname",		ctypes.POINTER(ctypes.c_char)),] )

LPALGETPROCADDRESS = _rpythonic_function_(		"LPALGETPROCADDRESS", ctypes.POINTER(ctypes.c_void_p), [
	("fname",		ctypes.POINTER(ctypes.c_char)),] )

LPALGETENUMVALUE = _rpythonic_function_(		"LPALGETENUMVALUE", ctypes.c_int, [
	("ename",		ctypes.POINTER(ctypes.c_char)),] )

LPALLISTENERF = _rpythonic_function_(		"LPALLISTENERF", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.c_float),] )

LPALLISTENER3F = _rpythonic_function_(		"LPALLISTENER3F", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.c_float),
	("value2",		ctypes.c_float),
	("value3",		ctypes.c_float),] )

LPALLISTENERFV = _rpythonic_function_(		"LPALLISTENERFV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

LPALLISTENERI = _rpythonic_function_(		"LPALLISTENERI", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.c_int),] )

LPALLISTENER3I = _rpythonic_function_(		"LPALLISTENER3I", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.c_int),
	("value2",		ctypes.c_int),
	("value3",		ctypes.c_int),] )

LPALLISTENERIV = _rpythonic_function_(		"LPALLISTENERIV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETLISTENERF = _rpythonic_function_(		"LPALGETLISTENERF", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETLISTENER3F = _rpythonic_function_(		"LPALGETLISTENER3F", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_float)),
	("value2",		ctypes.POINTER(ctypes.c_float)),
	("value3",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETLISTENERFV = _rpythonic_function_(		"LPALGETLISTENERFV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETLISTENERI = _rpythonic_function_(		"LPALGETLISTENERI", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETLISTENER3I = _rpythonic_function_(		"LPALGETLISTENER3I", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_int)),
	("value2",		ctypes.POINTER(ctypes.c_int)),
	("value3",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETLISTENERIV = _rpythonic_function_(		"LPALGETLISTENERIV", ctypes.c_void_p, [
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

LPALGENSOURCES = _rpythonic_function_(		"LPALGENSOURCES", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("sources",		ctypes.POINTER(ctypes.c_uint)),] )

LPALDELETESOURCES = _rpythonic_function_(		"LPALDELETESOURCES", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("sources",		ctypes.POINTER(ctypes.c_uint)),] )

LPALISSOURCE = _rpythonic_function_(		"LPALISSOURCE", ctypes.c_char, [
	("sid",		ctypes.c_uint),] )

LPALSOURCEF = _rpythonic_function_(		"LPALSOURCEF", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_float),] )

LPALSOURCE3F = _rpythonic_function_(		"LPALSOURCE3F", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_float),
	("value2",		ctypes.c_float),
	("value3",		ctypes.c_float),] )

LPALSOURCEFV = _rpythonic_function_(		"LPALSOURCEFV", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

LPALSOURCEI = _rpythonic_function_(		"LPALSOURCEI", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_int),] )

LPALSOURCE3I = _rpythonic_function_(		"LPALSOURCE3I", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_int),
	("value2",		ctypes.c_int),
	("value3",		ctypes.c_int),] )

LPALSOURCEIV = _rpythonic_function_(		"LPALSOURCEIV", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETSOURCEF = _rpythonic_function_(		"LPALGETSOURCEF", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETSOURCE3F = _rpythonic_function_(		"LPALGETSOURCE3F", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_float)),
	("value2",		ctypes.POINTER(ctypes.c_float)),
	("value3",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETSOURCEFV = _rpythonic_function_(		"LPALGETSOURCEFV", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETSOURCEI = _rpythonic_function_(		"LPALGETSOURCEI", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETSOURCE3I = _rpythonic_function_(		"LPALGETSOURCE3I", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_int)),
	("value2",		ctypes.POINTER(ctypes.c_int)),
	("value3",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETSOURCEIV = _rpythonic_function_(		"LPALGETSOURCEIV", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

LPALSOURCEPLAYV = _rpythonic_function_(		"LPALSOURCEPLAYV", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

LPALSOURCESTOPV = _rpythonic_function_(		"LPALSOURCESTOPV", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

LPALSOURCEREWINDV = _rpythonic_function_(		"LPALSOURCEREWINDV", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

LPALSOURCEPAUSEV = _rpythonic_function_(		"LPALSOURCEPAUSEV", ctypes.c_void_p, [
	("ns",		ctypes.c_int),
	("sids",		ctypes.POINTER(ctypes.c_uint)),] )

LPALSOURCEPLAY = _rpythonic_function_(		"LPALSOURCEPLAY", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

LPALSOURCESTOP = _rpythonic_function_(		"LPALSOURCESTOP", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

LPALSOURCEREWIND = _rpythonic_function_(		"LPALSOURCEREWIND", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

LPALSOURCEPAUSE = _rpythonic_function_(		"LPALSOURCEPAUSE", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),] )

LPALSOURCEQUEUEBUFFERS = _rpythonic_function_(		"LPALSOURCEQUEUEBUFFERS", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("numEntries",		ctypes.c_int),
	("bids",		ctypes.POINTER(ctypes.c_uint)),] )

LPALSOURCEUNQUEUEBUFFERS = _rpythonic_function_(		"LPALSOURCEUNQUEUEBUFFERS", ctypes.c_void_p, [
	("sid",		ctypes.c_uint),
	("numEntries",		ctypes.c_int),
	("bids",		ctypes.POINTER(ctypes.c_uint)),] )

LPALGENBUFFERS = _rpythonic_function_(		"LPALGENBUFFERS", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("buffers",		ctypes.POINTER(ctypes.c_uint)),] )

LPALDELETEBUFFERS = _rpythonic_function_(		"LPALDELETEBUFFERS", ctypes.c_void_p, [
	("n",		ctypes.c_int),
	("buffers",		ctypes.POINTER(ctypes.c_uint)),] )

LPALISBUFFER = _rpythonic_function_(		"LPALISBUFFER", ctypes.c_char, [
	("bid",		ctypes.c_uint),] )

LPALBUFFERDATA = _rpythonic_function_(		"LPALBUFFERDATA", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("format",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("size",		ctypes.c_int),
	("freq",		ctypes.c_int),] )

LPALBUFFERF = _rpythonic_function_(		"LPALBUFFERF", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_float),] )

LPALBUFFER3F = _rpythonic_function_(		"LPALBUFFER3F", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_float),
	("value2",		ctypes.c_float),
	("value3",		ctypes.c_float),] )

LPALBUFFERFV = _rpythonic_function_(		"LPALBUFFERFV", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

LPALBUFFERI = _rpythonic_function_(		"LPALBUFFERI", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.c_int),] )

LPALBUFFER3I = _rpythonic_function_(		"LPALBUFFER3I", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.c_int),
	("value2",		ctypes.c_int),
	("value3",		ctypes.c_int),] )

LPALBUFFERIV = _rpythonic_function_(		"LPALBUFFERIV", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETBUFFERF = _rpythonic_function_(		"LPALGETBUFFERF", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETBUFFER3F = _rpythonic_function_(		"LPALGETBUFFER3F", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_float)),
	("value2",		ctypes.POINTER(ctypes.c_float)),
	("value3",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETBUFFERFV = _rpythonic_function_(		"LPALGETBUFFERFV", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_float)),] )

LPALGETBUFFERI = _rpythonic_function_(		"LPALGETBUFFERI", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETBUFFER3I = _rpythonic_function_(		"LPALGETBUFFER3I", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("value1",		ctypes.POINTER(ctypes.c_int)),
	("value2",		ctypes.POINTER(ctypes.c_int)),
	("value3",		ctypes.POINTER(ctypes.c_int)),] )

LPALGETBUFFERIV = _rpythonic_function_(		"LPALGETBUFFERIV", ctypes.c_void_p, [
	("bid",		ctypes.c_uint),
	("param",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

LPALDOPPLERFACTOR = _rpythonic_function_(		"LPALDOPPLERFACTOR", ctypes.c_void_p, [
	("value",		ctypes.c_float),] )

LPALDOPPLERVELOCITY = _rpythonic_function_(		"LPALDOPPLERVELOCITY", ctypes.c_void_p, [
	("value",		ctypes.c_float),] )

LPALSPEEDOFSOUND = _rpythonic_function_(		"LPALSPEEDOFSOUND", ctypes.c_void_p, [
	("value",		ctypes.c_float),] )

LPALDISTANCEMODEL = _rpythonic_function_(		"LPALDISTANCEMODEL", ctypes.c_void_p, [
	("distanceModel",		ctypes.c_int),] )

alcCreateContext = _rpythonic_function_(		"alcCreateContext", ctypes.POINTER(ALCcontext_struct), [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("attrlist",		ctypes.POINTER(ctypes.c_int)),] )

alcMakeContextCurrent = _rpythonic_function_(		"alcMakeContextCurrent", ctypes.c_char, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

alcProcessContext = _rpythonic_function_(		"alcProcessContext", ctypes.c_void_p, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

alcSuspendContext = _rpythonic_function_(		"alcSuspendContext", ctypes.c_void_p, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

alcDestroyContext = _rpythonic_function_(		"alcDestroyContext", ctypes.c_void_p, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

alcGetCurrentContext = _rpythonic_function_(		"alcGetCurrentContext", ctypes.POINTER(ALCcontext_struct), [] )

alcGetContextsDevice = _rpythonic_function_(		"alcGetContextsDevice", ctypes.POINTER(ALCdevice_struct), [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

alcOpenDevice = _rpythonic_function_(		"alcOpenDevice", ctypes.POINTER(ALCdevice_struct), [
	("devicename",		ctypes.POINTER(ctypes.c_char)),] )

alcCloseDevice = _rpythonic_function_(		"alcCloseDevice", ctypes.c_char, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

alcGetError = _rpythonic_function_(		"alcGetError", ctypes.c_int, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

alcIsExtensionPresent = _rpythonic_function_(		"alcIsExtensionPresent", ctypes.c_char, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("extname",		ctypes.POINTER(ctypes.c_char)),] )

LPALCGETINTEGERV = _rpythonic_function_(		"LPALCGETINTEGERV", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("param",		ctypes.c_int),
	("size",		ctypes.c_int),
	("dest",		ctypes.POINTER(ctypes.c_int)),] )

LPALCCAPTUREOPENDEVICE = _rpythonic_function_(		"LPALCCAPTUREOPENDEVICE", ctypes.POINTER(ALCdevice_struct), [
	("devicename",		ctypes.POINTER(ctypes.c_char)),
	("frequency",		ctypes.c_uint),
	("format",		ctypes.c_int),
	("buffersize",		ctypes.c_int),] )

LPALCCAPTURECLOSEDEVICE = _rpythonic_function_(		"LPALCCAPTURECLOSEDEVICE", ctypes.c_char, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

LPALCCAPTURESTART = _rpythonic_function_(		"LPALCCAPTURESTART", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

alcCaptureOpenDevice = _rpythonic_function_(		"alcCaptureOpenDevice", ctypes.POINTER(ALCdevice_struct), [
	("devicename",		ctypes.POINTER(ctypes.c_char)),
	("frequency",		ctypes.c_uint),
	("format",		ctypes.c_int),
	("buffersize",		ctypes.c_int),] )

alcCaptureCloseDevice = _rpythonic_function_(		"alcCaptureCloseDevice", ctypes.c_char, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

alcCaptureStart = _rpythonic_function_(		"alcCaptureStart", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

alcCaptureStop = _rpythonic_function_(		"alcCaptureStop", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

alcCaptureSamples = _rpythonic_function_(		"alcCaptureSamples", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("buffer",		ctypes.POINTER(ctypes.c_void_p)),
	("samples",		ctypes.c_int),] )

LPALCCREATECONTEXT = _rpythonic_function_(		"LPALCCREATECONTEXT", ctypes.POINTER(ALCcontext_struct), [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("attrlist",		ctypes.POINTER(ctypes.c_int)),] )

LPALCMAKECONTEXTCURRENT = _rpythonic_function_(		"LPALCMAKECONTEXTCURRENT", ctypes.c_char, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

LPALCPROCESSCONTEXT = _rpythonic_function_(		"LPALCPROCESSCONTEXT", ctypes.c_void_p, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

LPALCSUSPENDCONTEXT = _rpythonic_function_(		"LPALCSUSPENDCONTEXT", ctypes.c_void_p, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

LPALCDESTROYCONTEXT = _rpythonic_function_(		"LPALCDESTROYCONTEXT", ctypes.c_void_p, [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

LPALCGETCURRENTCONTEXT = _rpythonic_function_(		"LPALCGETCURRENTCONTEXT", ctypes.POINTER(ALCcontext_struct), [] )

LPALCGETCONTEXTSDEVICE = _rpythonic_function_(		"LPALCGETCONTEXTSDEVICE", ctypes.POINTER(ALCdevice_struct), [
	("context",		ctypes.POINTER(ALCcontext_struct)),] )

LPALCOPENDEVICE = _rpythonic_function_(		"LPALCOPENDEVICE", ctypes.POINTER(ALCdevice_struct), [
	("devicename",		ctypes.POINTER(ctypes.c_char)),] )

LPALCCLOSEDEVICE = _rpythonic_function_(		"LPALCCLOSEDEVICE", ctypes.c_char, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

LPALCGETERROR = _rpythonic_function_(		"LPALCGETERROR", ctypes.c_int, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

LPALCCAPTURESTOP = _rpythonic_function_(		"LPALCCAPTURESTOP", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),] )

LPALCCAPTURESAMPLES = _rpythonic_function_(		"LPALCCAPTURESAMPLES", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("buffer",		ctypes.POINTER(ctypes.c_void_p)),
	("samples",		ctypes.c_int),] )

alcGetProcAddress = _rpythonic_function_(		"alcGetProcAddress", ctypes.POINTER(ctypes.c_void_p), [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("funcname",		ctypes.POINTER(ctypes.c_char)),] )

alcGetEnumValue = _rpythonic_function_(		"alcGetEnumValue", ctypes.c_int, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("enumname",		ctypes.POINTER(ctypes.c_char)),] )

alcGetString = _rpythonic_function_(		"alcGetString", ctypes.POINTER(ctypes.c_char), [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("param",		ctypes.c_int),] )

alcGetIntegerv = _rpythonic_function_(		"alcGetIntegerv", ctypes.c_void_p, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("param",		ctypes.c_int),
	("size",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_int)),] )

LPALCISEXTENSIONPRESENT = _rpythonic_function_(		"LPALCISEXTENSIONPRESENT", ctypes.c_char, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("extname",		ctypes.POINTER(ctypes.c_char)),] )

LPALCGETPROCADDRESS = _rpythonic_function_(		"LPALCGETPROCADDRESS", ctypes.POINTER(ctypes.c_void_p), [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("funcname",		ctypes.POINTER(ctypes.c_char)),] )

LPALCGETENUMVALUE = _rpythonic_function_(		"LPALCGETENUMVALUE", ctypes.c_int, [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("enumname",		ctypes.POINTER(ctypes.c_char)),] )

LPALCGETSTRING = _rpythonic_function_(		"LPALCGETSTRING", ctypes.POINTER(ctypes.c_char), [
	("device",		ctypes.POINTER(ALCdevice_struct)),
	("param",		ctypes.c_int),] )


_rpythonic_convert_structs_to_objects()

_rpythonic_setup_return_wrappers()
_rpythonic_make_nice_global_enums_()
_rpythonic_clean_up_missing_functions_()
_rpythonic_strip_prefixes_(['al', 'alc', 'AL_'])